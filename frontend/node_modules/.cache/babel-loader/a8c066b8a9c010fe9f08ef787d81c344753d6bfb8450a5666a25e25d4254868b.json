{"ast":null,"code":"var _s = $RefreshSig$();\n/**\r\n * useQubicWallet Hook\r\n * Manages Qubic wallet connection and state\r\n */\nimport { useState, useEffect, useCallback } from 'react';\nimport QubicService from '../services/qubicService';\nexport const useQubicWallet = () => {\n  _s();\n  const [state, setState] = useState({\n    wallet: null,\n    isConnecting: false,\n    isConnected: false,\n    error: null\n  });\n\n  // Check for existing wallet connection on mount\n  useEffect(() => {\n    checkExistingConnection();\n  }, []);\n\n  // Auto-refresh balance every 30 seconds\n  useEffect(() => {\n    if (!state.isConnected || !state.wallet) return;\n    const interval = setInterval(async () => {\n      try {\n        const balance = await QubicService.getBalance(state.wallet.address);\n        setState(prev => ({\n          ...prev,\n          wallet: prev.wallet ? {\n            ...prev.wallet,\n            balance\n          } : null\n        }));\n      } catch (error) {\n        console.error('Failed to refresh balance:', error);\n      }\n    }, 30000);\n    return () => clearInterval(interval);\n  }, [state.isConnected, state.wallet]);\n  const checkExistingConnection = async () => {\n    try {\n      // Check if wallet was previously connected (from localStorage)\n      const savedAddress = localStorage.getItem('qubic_wallet_address');\n      if (savedAddress) {\n        // Attempt to reconnect\n        await connect();\n      }\n    } catch (error) {\n      console.error('Failed to check existing connection:', error);\n    }\n  };\n  const connect = useCallback(async () => {\n    setState(prev => ({\n      ...prev,\n      isConnecting: true,\n      error: null\n    }));\n    try {\n      const wallet = await QubicService.connectWallet();\n\n      // Save connection to localStorage\n      localStorage.setItem('qubic_wallet_address', wallet.address);\n      setState({\n        wallet,\n        isConnecting: false,\n        isConnected: true,\n        error: null\n      });\n      return wallet;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Failed to connect wallet';\n      setState({\n        wallet: null,\n        isConnecting: false,\n        isConnected: false,\n        error: errorMessage\n      });\n      throw error;\n    }\n  }, []);\n  const disconnect = useCallback(() => {\n    // Clear saved connection\n    localStorage.removeItem('qubic_wallet_address');\n    setState({\n      wallet: null,\n      isConnecting: false,\n      isConnected: false,\n      error: null\n    });\n  }, []);\n  const refreshBalance = useCallback(async () => {\n    if (!state.wallet) return;\n    try {\n      const balance = await QubicService.getBalance(state.wallet.address);\n      setState(prev => ({\n        ...prev,\n        wallet: prev.wallet ? {\n          ...prev.wallet,\n          balance\n        } : null\n      }));\n    } catch (error) {\n      console.error('Failed to refresh balance:', error);\n    }\n  }, [state.wallet]);\n  return {\n    wallet: state.wallet,\n    isConnecting: state.isConnecting,\n    isConnected: state.isConnected,\n    error: state.error,\n    connect,\n    disconnect,\n    refreshBalance\n  };\n};\n_s(useQubicWallet, \"tad0lkaLVHrQVkG/lE7r1unOoiU=\");","map":{"version":3,"names":["useState","useEffect","useCallback","QubicService","useQubicWallet","_s","state","setState","wallet","isConnecting","isConnected","error","checkExistingConnection","interval","setInterval","balance","getBalance","address","prev","console","clearInterval","savedAddress","localStorage","getItem","connect","connectWallet","setItem","errorMessage","Error","message","disconnect","removeItem","refreshBalance"],"sources":["C:/Users/USER/Documents/GitHub/PROG/New folder/Wil/AI-Exectuor/frontend/src/hooks/useQubicWallet.ts"],"sourcesContent":["/**\r\n * useQubicWallet Hook\r\n * Manages Qubic wallet connection and state\r\n */\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport QubicService, { QubicWallet } from '../services/qubicService';\r\n\r\ninterface WalletState {\r\n  wallet: QubicWallet | null;\r\n  isConnecting: boolean;\r\n  isConnected: boolean;\r\n  error: string | null;\r\n}\r\n\r\nexport const useQubicWallet = () => {\r\n  const [state, setState] = useState<WalletState>({\r\n    wallet: null,\r\n    isConnecting: false,\r\n    isConnected: false,\r\n    error: null\r\n  });\r\n\r\n  // Check for existing wallet connection on mount\r\n  useEffect(() => {\r\n    checkExistingConnection();\r\n  }, []);\r\n\r\n  // Auto-refresh balance every 30 seconds\r\n  useEffect(() => {\r\n    if (!state.isConnected || !state.wallet) return;\r\n\r\n    const interval = setInterval(async () => {\r\n      try {\r\n        const balance = await QubicService.getBalance(state.wallet!.address);\r\n        setState(prev => ({\r\n          ...prev,\r\n          wallet: prev.wallet ? { ...prev.wallet, balance } : null\r\n        }));\r\n      } catch (error) {\r\n        console.error('Failed to refresh balance:', error);\r\n      }\r\n    }, 30000);\r\n\r\n    return () => clearInterval(interval);\r\n  }, [state.isConnected, state.wallet]);\r\n\r\n  const checkExistingConnection = async () => {\r\n    try {\r\n      // Check if wallet was previously connected (from localStorage)\r\n      const savedAddress = localStorage.getItem('qubic_wallet_address');\r\n      if (savedAddress) {\r\n        // Attempt to reconnect\r\n        await connect();\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to check existing connection:', error);\r\n    }\r\n  };\r\n\r\n  const connect = useCallback(async () => {\r\n    setState(prev => ({ ...prev, isConnecting: true, error: null }));\r\n\r\n    try {\r\n      const wallet = await QubicService.connectWallet();\r\n      \r\n      // Save connection to localStorage\r\n      localStorage.setItem('qubic_wallet_address', wallet.address);\r\n      \r\n      setState({\r\n        wallet,\r\n        isConnecting: false,\r\n        isConnected: true,\r\n        error: null\r\n      });\r\n\r\n      return wallet;\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to connect wallet';\r\n      \r\n      setState({\r\n        wallet: null,\r\n        isConnecting: false,\r\n        isConnected: false,\r\n        error: errorMessage\r\n      });\r\n\r\n      throw error;\r\n    }\r\n  }, []);\r\n\r\n  const disconnect = useCallback(() => {\r\n    // Clear saved connection\r\n    localStorage.removeItem('qubic_wallet_address');\r\n    \r\n    setState({\r\n      wallet: null,\r\n      isConnecting: false,\r\n      isConnected: false,\r\n      error: null\r\n    });\r\n  }, []);\r\n\r\n  const refreshBalance = useCallback(async () => {\r\n    if (!state.wallet) return;\r\n\r\n    try {\r\n      const balance = await QubicService.getBalance(state.wallet.address);\r\n      setState(prev => ({\r\n        ...prev,\r\n        wallet: prev.wallet ? { ...prev.wallet, balance } : null\r\n      }));\r\n    } catch (error) {\r\n      console.error('Failed to refresh balance:', error);\r\n    }\r\n  }, [state.wallet]);\r\n\r\n  return {\r\n    wallet: state.wallet,\r\n    isConnecting: state.isConnecting,\r\n    isConnected: state.isConnected,\r\n    error: state.error,\r\n    connect,\r\n    disconnect,\r\n    refreshBalance\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}