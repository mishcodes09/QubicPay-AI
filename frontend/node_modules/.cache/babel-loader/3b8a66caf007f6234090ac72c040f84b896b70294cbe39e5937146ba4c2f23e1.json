{"ast":null,"code":"/**\r\n * Qubic Service - Blockchain Integration\r\n * Handles wallet connections, contract deployment, and transactions\r\n * \r\n * NOTE: This is a mock implementation for demo purposes.\r\n * In production, replace with actual Qubic TypeScript Library:\r\n * - @qubic-lib/qubic-ts-library\r\n * - https://github.com/qubic-lib/qubic-ts-library\r\n */\n\nconst CONFIG = {\n  CONTRACT_ID: process.env.REACT_APP_CONTRACT_ID || 'QUBIC_CONTRACT_ESCROW',\n  QUBIC_RPC: process.env.REACT_APP_QUBIC_RPC || 'https://testnet-rpc.qubic.org',\n  NETWORK_ID: 1,\n  // 1 = testnet, 0 = mainnet\n  PLATFORM_FEE_PERCENT: 3\n};\nclass QubicService {\n  /**\r\n   * Connect to Qubic wallet\r\n   * In production: Use Qubic wallet browser extension or SDK\r\n   */\n  static async connectWallet() {\n    // Simulate wallet connection delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // In production, this would:\n    // 1. Check for Qubic wallet extension\n    // 2. Request user permission\n    // 3. Get wallet address and public key\n    // 4. Query balance from RPC\n\n    const mockWallet = {\n      address: this.generateMockAddress(),\n      publicKey: this.generateMockPublicKey(),\n      balance: Math.floor(Math.random() * 10000) + 5000\n    };\n    console.log('[Qubic Service] Wallet connected:', mockWallet.address);\n    return mockWallet;\n  }\n\n  /**\r\n   * Deploy smart contract to Qubic network\r\n   * In production: Use Qubic CLI or deployment SDK\r\n   */\n  static async deployContract(brandAddress, oracleAddress) {\n    console.log('[Qubic Service] Deploying contract...');\n\n    // Simulate deployment delay\n    await new Promise(resolve => setTimeout(resolve, 2000));\n\n    // In production, this would:\n    // 1. Compile contract (if not pre-compiled)\n    // 2. Create IPO transaction\n    // 3. Broadcast to Qubic network\n    // 4. Wait for confirmation\n\n    const result = {\n      contractId: CONFIG.CONTRACT_ID || `CONTRACT_${Date.now()}`,\n      txHash: this.generateMockTxHash(),\n      deployTick: Math.floor(Date.now() / 1000),\n      success: true\n    };\n    console.log('[Qubic Service] Contract deployed:', result.contractId);\n    return result;\n  }\n\n  /**\r\n   * Deposit funds into escrow contract\r\n   * In production: Build and sign transaction using Qubic SDK\r\n   */\n  static async depositFunds(contractId, amount, influencerId, retentionDays = 7) {\n    console.log('[Qubic Service] Depositing', amount, 'QUBIC to contract');\n\n    // Simulate transaction delay\n    await new Promise(resolve => setTimeout(resolve, 1500));\n\n    // Calculate platform fee\n    const fee = Math.round(amount * (CONFIG.PLATFORM_FEE_PERCENT / 100));\n    const netAmount = amount - fee;\n\n    // In production, this would:\n    // 1. Build transaction with depositFunds procedure\n    // 2. Sign with user's private key\n    // 3. Broadcast to Qubic RPC\n    // 4. Wait for confirmation\n\n    const result = {\n      success: true,\n      txHash: this.generateMockTxHash(),\n      amount: netAmount,\n      fee: fee,\n      timestamp: Date.now()\n    };\n    console.log('[Qubic Service] Deposit successful:', result.txHash);\n    return result;\n  }\n\n  /**\r\n   * Release payment to influencer\r\n   * In production: Call releasePayment() procedure on contract\r\n   */\n  static async releasePayment(contractId) {\n    console.log('[Qubic Service] Releasing payment...');\n    await new Promise(resolve => setTimeout(resolve, 2000));\n\n    // In production, this would:\n    // 1. Build transaction calling releasePayment()\n    // 2. Contract validates: score >= 95, retention period met\n    // 3. Contract transfers funds to influencer (zero fee)\n    // 4. Emit payment event\n\n    const result = {\n      success: true,\n      txHash: this.generateMockTxHash(),\n      timestamp: Date.now()\n    };\n    console.log('[Qubic Service] Payment released:', result.txHash);\n    return result;\n  }\n\n  /**\r\n   * Refund funds to brand\r\n   * In production: Call refundFunds() procedure on contract\r\n   */\n  static async refundFunds(contractId) {\n    console.log('[Qubic Service] Processing refund...');\n    await new Promise(resolve => setTimeout(resolve, 1500));\n\n    // In production, this would:\n    // 1. Build transaction calling refundFunds()\n    // 2. Contract validates: score < 95 (fraud detected)\n    // 3. Contract transfers funds back to brand\n    // 4. Emit refund event\n\n    const result = {\n      success: true,\n      txHash: this.generateMockTxHash(),\n      timestamp: Date.now()\n    };\n    console.log('[Qubic Service] Refund processed:', result.txHash);\n    return result;\n  }\n\n  /**\r\n   * Query contract state\r\n   * In production: Use Qubic RPC to query contract state\r\n   */\n  static async getContractState(contractId) {\n    try {\n      // In production, query actual contract state from RPC\n      // const response = await fetch(`${CONFIG.QUBIC_RPC}/contract/${contractId}/state`);\n      // return await response.json();\n\n      return {\n        isActive: true,\n        escrowBalance: 0,\n        verificationScore: 0,\n        isVerified: false,\n        isPaid: false,\n        isRefunded: false\n      };\n    } catch (error) {\n      console.error('[Qubic Service] Failed to query contract state:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Get wallet balance\r\n   * In production: Query from Qubic RPC\r\n   */\n  static async getBalance(address) {\n    try {\n      // In production:\n      // const response = await fetch(`${CONFIG.QUBIC_RPC}/balance/${address}`);\n      // const data = await response.json();\n      // return data.balance;\n\n      return Math.floor(Math.random() * 10000) + 5000;\n    } catch (error) {\n      console.error('[Qubic Service] Failed to get balance:', error);\n      return 0;\n    }\n  }\n\n  /**\r\n   * Get current network tick\r\n   * In production: Query from Qubic RPC\r\n   */\n  static async getCurrentTick() {\n    try {\n      const response = await fetch(`${CONFIG.QUBIC_RPC}/tick`);\n      const data = await response.json();\n      return data.tick || Math.floor(Date.now() / 1000);\n    } catch (error) {\n      console.error('[Qubic Service] Failed to get current tick:', error);\n      return Math.floor(Date.now() / 1000);\n    }\n  }\n\n  /**\r\n   * Wait for transaction confirmation\r\n   * In production: Poll RPC for transaction status\r\n   */\n  static async waitForConfirmation(txHash, maxWaitMs = 30000) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < maxWaitMs) {\n      // In production: Query transaction status\n      // const status = await this.getTransactionStatus(txHash);\n      // if (status === 'confirmed') return true;\n      // if (status === 'failed') return false;\n\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      // Mock: Always confirm after 4 seconds\n      if (Date.now() - startTime >= 4000) {\n        console.log('[Qubic Service] Transaction confirmed:', txHash);\n        return true;\n      }\n    }\n    console.warn('[Qubic Service] Transaction confirmation timeout');\n    return false;\n  }\n\n  // ============================================================================\n  // HELPER METHODS (Mock implementations for demo)\n  // ============================================================================\n\n  static generateMockAddress() {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    let address = 'QUBIC';\n    for (let i = 0; i < 56; i++) {\n      address += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return address;\n  }\n  static generateMockPublicKey() {\n    return 'PK_' + Math.random().toString(36).substring(2, 15).toUpperCase();\n  }\n  static generateMockTxHash() {\n    return '0x' + Array.from({\n      length: 64\n    }, () => Math.floor(Math.random() * 16).toString(16)).join('');\n  }\n\n  /**\r\n   * Estimate transaction fee (Always 0 on Qubic)\r\n   */\n  static estimateFee() {\n    return 0; // Qubic has zero transaction fees\n  }\n\n  /**\r\n   * Get network info\r\n   */\n  static getNetworkInfo() {\n    return {\n      name: CONFIG.NETWORK_ID === 1 ? 'Qubic Testnet' : 'Qubic Mainnet',\n      chainId: CONFIG.NETWORK_ID,\n      rpc: CONFIG.QUBIC_RPC\n    };\n  }\n}\nexport default QubicService;","map":{"version":3,"names":["CONFIG","CONTRACT_ID","process","env","REACT_APP_CONTRACT_ID","QUBIC_RPC","REACT_APP_QUBIC_RPC","NETWORK_ID","PLATFORM_FEE_PERCENT","QubicService","connectWallet","Promise","resolve","setTimeout","mockWallet","address","generateMockAddress","publicKey","generateMockPublicKey","balance","Math","floor","random","console","log","deployContract","brandAddress","oracleAddress","result","contractId","Date","now","txHash","generateMockTxHash","deployTick","success","depositFunds","amount","influencerId","retentionDays","fee","round","netAmount","timestamp","releasePayment","refundFunds","getContractState","isActive","escrowBalance","verificationScore","isVerified","isPaid","isRefunded","error","getBalance","getCurrentTick","response","fetch","data","json","tick","waitForConfirmation","maxWaitMs","startTime","warn","chars","i","charAt","length","toString","substring","toUpperCase","Array","from","join","estimateFee","getNetworkInfo","name","chainId","rpc"],"sources":["C:/Users/USER/Documents/GitHub/PROG/New folder/Wil/AI-Exectuor/frontend/src/services/qubicService.ts"],"sourcesContent":["/**\r\n * Qubic Service - Blockchain Integration\r\n * Handles wallet connections, contract deployment, and transactions\r\n * \r\n * NOTE: This is a mock implementation for demo purposes.\r\n * In production, replace with actual Qubic TypeScript Library:\r\n * - @qubic-lib/qubic-ts-library\r\n * - https://github.com/qubic-lib/qubic-ts-library\r\n */\r\n\r\nconst CONFIG = {\r\n  CONTRACT_ID: process.env.REACT_APP_CONTRACT_ID || 'QUBIC_CONTRACT_ESCROW',\r\n  QUBIC_RPC: process.env.REACT_APP_QUBIC_RPC || 'https://testnet-rpc.qubic.org',\r\n  NETWORK_ID: 1, // 1 = testnet, 0 = mainnet\r\n  PLATFORM_FEE_PERCENT: 3\r\n};\r\n\r\nexport interface QubicWallet {\r\n  address: string;\r\n  publicKey: string;\r\n  balance: number;\r\n}\r\n\r\nexport interface ContractDeployResult {\r\n  contractId: string;\r\n  txHash: string;\r\n  deployTick: number;\r\n  success: boolean;\r\n}\r\n\r\nexport interface TransactionResult {\r\n  success: boolean;\r\n  txHash: string;\r\n  amount?: number;\r\n  fee?: number;\r\n  timestamp: number;\r\n}\r\n\r\nclass QubicService {\r\n  /**\r\n   * Connect to Qubic wallet\r\n   * In production: Use Qubic wallet browser extension or SDK\r\n   */\r\n  static async connectWallet(): Promise<QubicWallet> {\r\n    // Simulate wallet connection delay\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n    // In production, this would:\r\n    // 1. Check for Qubic wallet extension\r\n    // 2. Request user permission\r\n    // 3. Get wallet address and public key\r\n    // 4. Query balance from RPC\r\n\r\n    const mockWallet: QubicWallet = {\r\n      address: this.generateMockAddress(),\r\n      publicKey: this.generateMockPublicKey(),\r\n      balance: Math.floor(Math.random() * 10000) + 5000\r\n    };\r\n\r\n    console.log('[Qubic Service] Wallet connected:', mockWallet.address);\r\n    return mockWallet;\r\n  }\r\n\r\n  /**\r\n   * Deploy smart contract to Qubic network\r\n   * In production: Use Qubic CLI or deployment SDK\r\n   */\r\n  static async deployContract(\r\n    brandAddress: string,\r\n    oracleAddress: string\r\n  ): Promise<ContractDeployResult> {\r\n    console.log('[Qubic Service] Deploying contract...');\r\n    \r\n    // Simulate deployment delay\r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n    // In production, this would:\r\n    // 1. Compile contract (if not pre-compiled)\r\n    // 2. Create IPO transaction\r\n    // 3. Broadcast to Qubic network\r\n    // 4. Wait for confirmation\r\n\r\n    const result: ContractDeployResult = {\r\n      contractId: CONFIG.CONTRACT_ID || `CONTRACT_${Date.now()}`,\r\n      txHash: this.generateMockTxHash(),\r\n      deployTick: Math.floor(Date.now() / 1000),\r\n      success: true\r\n    };\r\n\r\n    console.log('[Qubic Service] Contract deployed:', result.contractId);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Deposit funds into escrow contract\r\n   * In production: Build and sign transaction using Qubic SDK\r\n   */\r\n  static async depositFunds(\r\n    contractId: string,\r\n    amount: number,\r\n    influencerId: string,\r\n    retentionDays: number = 7\r\n  ): Promise<TransactionResult> {\r\n    console.log('[Qubic Service] Depositing', amount, 'QUBIC to contract');\r\n    \r\n    // Simulate transaction delay\r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n\r\n    // Calculate platform fee\r\n    const fee = Math.round(amount * (CONFIG.PLATFORM_FEE_PERCENT / 100));\r\n    const netAmount = amount - fee;\r\n\r\n    // In production, this would:\r\n    // 1. Build transaction with depositFunds procedure\r\n    // 2. Sign with user's private key\r\n    // 3. Broadcast to Qubic RPC\r\n    // 4. Wait for confirmation\r\n\r\n    const result: TransactionResult = {\r\n      success: true,\r\n      txHash: this.generateMockTxHash(),\r\n      amount: netAmount,\r\n      fee: fee,\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    console.log('[Qubic Service] Deposit successful:', result.txHash);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Release payment to influencer\r\n   * In production: Call releasePayment() procedure on contract\r\n   */\r\n  static async releasePayment(contractId: string): Promise<TransactionResult> {\r\n    console.log('[Qubic Service] Releasing payment...');\r\n    \r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n    // In production, this would:\r\n    // 1. Build transaction calling releasePayment()\r\n    // 2. Contract validates: score >= 95, retention period met\r\n    // 3. Contract transfers funds to influencer (zero fee)\r\n    // 4. Emit payment event\r\n\r\n    const result: TransactionResult = {\r\n      success: true,\r\n      txHash: this.generateMockTxHash(),\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    console.log('[Qubic Service] Payment released:', result.txHash);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Refund funds to brand\r\n   * In production: Call refundFunds() procedure on contract\r\n   */\r\n  static async refundFunds(contractId: string): Promise<TransactionResult> {\r\n    console.log('[Qubic Service] Processing refund...');\r\n    \r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n\r\n    // In production, this would:\r\n    // 1. Build transaction calling refundFunds()\r\n    // 2. Contract validates: score < 95 (fraud detected)\r\n    // 3. Contract transfers funds back to brand\r\n    // 4. Emit refund event\r\n\r\n    const result: TransactionResult = {\r\n      success: true,\r\n      txHash: this.generateMockTxHash(),\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    console.log('[Qubic Service] Refund processed:', result.txHash);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Query contract state\r\n   * In production: Use Qubic RPC to query contract state\r\n   */\r\n  static async getContractState(contractId: string): Promise<any> {\r\n    try {\r\n      // In production, query actual contract state from RPC\r\n      // const response = await fetch(`${CONFIG.QUBIC_RPC}/contract/${contractId}/state`);\r\n      // return await response.json();\r\n\r\n      return {\r\n        isActive: true,\r\n        escrowBalance: 0,\r\n        verificationScore: 0,\r\n        isVerified: false,\r\n        isPaid: false,\r\n        isRefunded: false\r\n      };\r\n    } catch (error) {\r\n      console.error('[Qubic Service] Failed to query contract state:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get wallet balance\r\n   * In production: Query from Qubic RPC\r\n   */\r\n  static async getBalance(address: string): Promise<number> {\r\n    try {\r\n      // In production:\r\n      // const response = await fetch(`${CONFIG.QUBIC_RPC}/balance/${address}`);\r\n      // const data = await response.json();\r\n      // return data.balance;\r\n\r\n      return Math.floor(Math.random() * 10000) + 5000;\r\n    } catch (error) {\r\n      console.error('[Qubic Service] Failed to get balance:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current network tick\r\n   * In production: Query from Qubic RPC\r\n   */\r\n  static async getCurrentTick(): Promise<number> {\r\n    try {\r\n      const response = await fetch(`${CONFIG.QUBIC_RPC}/tick`);\r\n      const data = await response.json();\r\n      return data.tick || Math.floor(Date.now() / 1000);\r\n    } catch (error) {\r\n      console.error('[Qubic Service] Failed to get current tick:', error);\r\n      return Math.floor(Date.now() / 1000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wait for transaction confirmation\r\n   * In production: Poll RPC for transaction status\r\n   */\r\n  static async waitForConfirmation(txHash: string, maxWaitMs: number = 30000): Promise<boolean> {\r\n    const startTime = Date.now();\r\n    \r\n    while (Date.now() - startTime < maxWaitMs) {\r\n      // In production: Query transaction status\r\n      // const status = await this.getTransactionStatus(txHash);\r\n      // if (status === 'confirmed') return true;\r\n      // if (status === 'failed') return false;\r\n      \r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n      \r\n      // Mock: Always confirm after 4 seconds\r\n      if (Date.now() - startTime >= 4000) {\r\n        console.log('[Qubic Service] Transaction confirmed:', txHash);\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    console.warn('[Qubic Service] Transaction confirmation timeout');\r\n    return false;\r\n  }\r\n\r\n  // ============================================================================\r\n  // HELPER METHODS (Mock implementations for demo)\r\n  // ============================================================================\r\n\r\n  private static generateMockAddress(): string {\r\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    let address = 'QUBIC';\r\n    for (let i = 0; i < 56; i++) {\r\n      address += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    return address;\r\n  }\r\n\r\n  private static generateMockPublicKey(): string {\r\n    return 'PK_' + Math.random().toString(36).substring(2, 15).toUpperCase();\r\n  }\r\n\r\n  private static generateMockTxHash(): string {\r\n    return '0x' + Array.from({ length: 64 }, () => \r\n      Math.floor(Math.random() * 16).toString(16)\r\n    ).join('');\r\n  }\r\n\r\n  /**\r\n   * Estimate transaction fee (Always 0 on Qubic)\r\n   */\r\n  static estimateFee(): number {\r\n    return 0; // Qubic has zero transaction fees\r\n  }\r\n\r\n  /**\r\n   * Get network info\r\n   */\r\n  static getNetworkInfo(): { name: string; chainId: number; rpc: string } {\r\n    return {\r\n      name: CONFIG.NETWORK_ID === 1 ? 'Qubic Testnet' : 'Qubic Mainnet',\r\n      chainId: CONFIG.NETWORK_ID,\r\n      rpc: CONFIG.QUBIC_RPC\r\n    };\r\n  }\r\n}\r\n\r\nexport default QubicService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}