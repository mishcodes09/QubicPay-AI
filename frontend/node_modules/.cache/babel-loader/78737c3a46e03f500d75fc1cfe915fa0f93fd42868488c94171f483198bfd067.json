{"ast":null,"code":"/**\r\n * Qubic Service - Blockchain Integration\r\n * Handles wallet connections, contract deployment, and transactions\r\n * \r\n * NOTE: This is a mock implementation for demo purposes.\r\n * In production, replace with actual Qubic TypeScript Library:\r\n * - @qubic-lib/qubic-ts-library\r\n * - https://github.com/qubic-lib/qubic-ts-library\r\n */\n\nconst CONFIG = {\n  CONTRACT_ID: process.env.REACT_APP_CONTRACT_ID || 'QUBIC_CONTRACT_ESCROW',\n  QUBIC_RPC: process.env.REACT_APP_QUBIC_RPC || 'https://testnet-rpc.qubic.org',\n  NETWORK_ID: 1,\n  // 1 = testnet, 0 = mainnet\n  PLATFORM_FEE_PERCENT: 3\n};\nclass QubicService {\n  /**\r\n   * Connect to Qubic wallet\r\n   * In production: Use Qubic wallet browser extension or SDK\r\n   */\n  static async connectWallet() {\n    // Simulate wallet connection delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // In production, this would:\n    // 1. Check for Qubic wallet extension\n    // 2. Request user permission\n    // 3. Get wallet address and public key\n    // 4. Query balance from RPC\n\n    const mockWallet = {\n      address: this.generateMockAddress(),\n      publicKey: this.generateMockPublicKey(),\n      balance: Math.floor(Math.random() * 10000) + 5000\n    };\n    console.log('[Qubic Service] Wallet connected:', mockWallet.address);\n    return mockWallet;\n  }\n\n  /**\r\n   * Deploy smart contract to Qubic network\r\n   * In production: Use Qubic CLI or deployment SDK\r\n   */\n  static async deployContract(_brandAddress, _oracleAddress) {\n    console.log('[Qubic Service] Deploying contract...');\n\n    // Simulate deployment delay\n    await new Promise(resolve => setTimeout(resolve, 2000));\n\n    // In production, this would:\n    // 1. Compile contract (if not pre-compiled)\n    // 2. Create IPO transaction\n    // 3. Broadcast to Qubic network\n    // 4. Wait for confirmation\n\n    const result = {\n      contractId: CONFIG.CONTRACT_ID || `CONTRACT_${Date.now()}`,\n      txHash: this.generateMockTxHash(),\n      deployTick: Math.floor(Date.now() / 1000),\n      success: true\n    };\n    console.log('[Qubic Service] Contract deployed:', result.contractId);\n    return result;\n  }\n\n  /**\r\n   * Deposit funds into escrow contract\r\n   * In production: Build and sign transaction using Qubic SDK\r\n   */\n  static async depositFunds(_contractId, amount, _influencerId, _retentionDays = 7) {\n    console.log('[Qubic Service] Depositing', amount, 'QUBIC to contract');\n\n    // Simulate transaction delay\n    await new Promise(resolve => setTimeout(resolve, 1500));\n\n    // Calculate platform fee\n    const fee = Math.round(amount * (CONFIG.PLATFORM_FEE_PERCENT / 100));\n    const netAmount = amount - fee;\n\n    // In production, this would:\n    // 1. Build transaction with depositFunds procedure\n    // 2. Sign with user's private key\n    // 3. Broadcast to Qubic RPC\n    // 4. Wait for confirmation\n\n    const result = {\n      success: true,\n      txHash: this.generateMockTxHash(),\n      amount: netAmount,\n      fee: fee,\n      timestamp: Date.now()\n    };\n    console.log('[Qubic Service] Deposit successful:', result.txHash);\n    return result;\n  }\n\n  /**\r\n   * Release payment to influencer\r\n   * In production: Call releasePayment() procedure on contract\r\n   */\n  static async releasePayment(_contractId) {\n    console.log('[Qubic Service] Releasing payment...');\n    await new Promise(resolve => setTimeout(resolve, 2000));\n\n    // In production, this would:\n    // 1. Build transaction calling releasePayment()\n    // 2. Contract validates: score >= 95, retention period met\n    // 3. Contract transfers funds to influencer (zero fee)\n    // 4. Emit payment event\n\n    const result = {\n      success: true,\n      txHash: this.generateMockTxHash(),\n      timestamp: Date.now()\n    };\n    console.log('[Qubic Service] Payment released:', result.txHash);\n    return result;\n  }\n\n  /**\r\n   * Refund funds to brand\r\n   * In production: Call refundFunds() procedure on contract\r\n   */\n  static async refundFunds(_contractId) {\n    console.log('[Qubic Service] Processing refund...');\n    await new Promise(resolve => setTimeout(resolve, 1500));\n\n    // In production, this would:\n    // 1. Build transaction calling refundFunds()\n    // 2. Contract validates: score < 95 (fraud detected)\n    // 3. Contract transfers funds back to brand\n    // 4. Emit refund event\n\n    const result = {\n      success: true,\n      txHash: this.generateMockTxHash(),\n      timestamp: Date.now()\n    };\n    console.log('[Qubic Service] Refund processed:', result.txHash);\n    return result;\n  }\n\n  /**\r\n   * Query contract state\r\n   * In production: Use Qubic RPC to query contract state\r\n   */\n  static async getContractState(_contractId) {\n    try {\n      // In production, query actual contract state from RPC\n      // const response = await fetch(`${CONFIG.QUBIC_RPC}/contract/${_contractId}/state`);\n      // return await response.json();\n\n      return {\n        isActive: true,\n        escrowBalance: 0,\n        verificationScore: 0,\n        isVerified: false,\n        isPaid: false,\n        isRefunded: false\n      };\n    } catch (error) {\n      console.error('[Qubic Service] Failed to query contract state:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Get wallet balance\r\n   * In production: Query from Qubic RPC\r\n   */\n  static async getBalance(_address) {\n    try {\n      // In production:\n      // const response = await fetch(`${CONFIG.QUBIC_RPC}/balance/${_address}`);\n      // const data = await response.json();\n      // return data.balance;\n\n      return Math.floor(Math.random() * 10000) + 5000;\n    } catch (error) {\n      console.error('[Qubic Service] Failed to get balance:', error);\n      return 0;\n    }\n  }\n\n  /**\r\n   * Get current network tick\r\n   * In production: Query from Qubic RPC\r\n   */\n  static async getCurrentTick() {\n    try {\n      const response = await fetch(`${CONFIG.QUBIC_RPC}/tick`);\n      const data = await response.json();\n      return data.tick || Math.floor(Date.now() / 1000);\n    } catch (error) {\n      console.error('[Qubic Service] Failed to get current tick:', error);\n      return Math.floor(Date.now() / 1000);\n    }\n  }\n\n  /**\r\n   * Wait for transaction confirmation\r\n   * In production: Poll RPC for transaction status\r\n   */\n  static async waitForConfirmation(txHash, maxWaitMs = 30000) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < maxWaitMs) {\n      // In production: Query transaction status\n      // const status = await this.getTransactionStatus(txHash);\n      // if (status === 'confirmed') return true;\n      // if (status === 'failed') return false;\n\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      // Mock: Always confirm after 4 seconds\n      if (Date.now() - startTime >= 4000) {\n        console.log('[Qubic Service] Transaction confirmed:', txHash);\n        return true;\n      }\n    }\n    console.warn('[Qubic Service] Transaction confirmation timeout');\n    return false;\n  }\n\n  // ============================================================================\n  // HELPER METHODS (Mock implementations for demo)\n  // ============================================================================\n\n  static generateMockAddress() {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    let address = 'QUBIC';\n    for (let i = 0; i < 56; i++) {\n      address += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return address;\n  }\n  static generateMockPublicKey() {\n    return 'PK_' + Math.random().toString(36).substring(2, 15).toUpperCase();\n  }\n  static generateMockTxHash() {\n    return '0x' + Array.from({\n      length: 64\n    }, () => Math.floor(Math.random() * 16).toString(16)).join('');\n  }\n\n  /**\r\n   * Estimate transaction fee (Always 0 on Qubic)\r\n   */\n  static estimateFee() {\n    return 0; // Qubic has zero transaction fees\n  }\n\n  /**\r\n   * Get network info\r\n   */\n  static getNetworkInfo() {\n    return {\n      name: CONFIG.NETWORK_ID === 1 ? 'Qubic Testnet' : 'Qubic Mainnet',\n      chainId: CONFIG.NETWORK_ID,\n      rpc: CONFIG.QUBIC_RPC\n    };\n  }\n}\nexport default QubicService;","map":{"version":3,"names":["CONFIG","CONTRACT_ID","process","env","REACT_APP_CONTRACT_ID","QUBIC_RPC","REACT_APP_QUBIC_RPC","NETWORK_ID","PLATFORM_FEE_PERCENT","QubicService","connectWallet","Promise","resolve","setTimeout","mockWallet","address","generateMockAddress","publicKey","generateMockPublicKey","balance","Math","floor","random","console","log","deployContract","_brandAddress","_oracleAddress","result","contractId","Date","now","txHash","generateMockTxHash","deployTick","success","depositFunds","_contractId","amount","_influencerId","_retentionDays","fee","round","netAmount","timestamp","releasePayment","refundFunds","getContractState","isActive","escrowBalance","verificationScore","isVerified","isPaid","isRefunded","error","getBalance","_address","getCurrentTick","response","fetch","data","json","tick","waitForConfirmation","maxWaitMs","startTime","warn","chars","i","charAt","length","toString","substring","toUpperCase","Array","from","join","estimateFee","getNetworkInfo","name","chainId","rpc"],"sources":["C:/Users/USER/Documents/GitHub/PROG/New folder/Wil/AI-Exectuor/frontend/src/services/qubicService.ts"],"sourcesContent":["/**\r\n * Qubic Service - Blockchain Integration\r\n * Handles wallet connections, contract deployment, and transactions\r\n * \r\n * NOTE: This is a mock implementation for demo purposes.\r\n * In production, replace with actual Qubic TypeScript Library:\r\n * - @qubic-lib/qubic-ts-library\r\n * - https://github.com/qubic-lib/qubic-ts-library\r\n */\r\n\r\nconst CONFIG = {\r\n  CONTRACT_ID: process.env.REACT_APP_CONTRACT_ID || 'QUBIC_CONTRACT_ESCROW',\r\n  QUBIC_RPC: process.env.REACT_APP_QUBIC_RPC || 'https://testnet-rpc.qubic.org',\r\n  NETWORK_ID: 1, // 1 = testnet, 0 = mainnet\r\n  PLATFORM_FEE_PERCENT: 3\r\n};\r\n\r\nexport interface QubicWallet {\r\n  address: string;\r\n  publicKey: string;\r\n  balance: number;\r\n}\r\n\r\nexport interface ContractDeployResult {\r\n  contractId: string;\r\n  txHash: string;\r\n  deployTick: number;\r\n  success: boolean;\r\n}\r\n\r\nexport interface TransactionResult {\r\n  success: boolean;\r\n  txHash: string;\r\n  amount?: number;\r\n  fee?: number;\r\n  timestamp: number;\r\n}\r\n\r\nclass QubicService {\r\n  /**\r\n   * Connect to Qubic wallet\r\n   * In production: Use Qubic wallet browser extension or SDK\r\n   */\r\n  static async connectWallet(): Promise<QubicWallet> {\r\n    // Simulate wallet connection delay\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n    // In production, this would:\r\n    // 1. Check for Qubic wallet extension\r\n    // 2. Request user permission\r\n    // 3. Get wallet address and public key\r\n    // 4. Query balance from RPC\r\n\r\n    const mockWallet: QubicWallet = {\r\n      address: this.generateMockAddress(),\r\n      publicKey: this.generateMockPublicKey(),\r\n      balance: Math.floor(Math.random() * 10000) + 5000\r\n    };\r\n\r\n    console.log('[Qubic Service] Wallet connected:', mockWallet.address);\r\n    return mockWallet;\r\n  }\r\n\r\n  /**\r\n   * Deploy smart contract to Qubic network\r\n   * In production: Use Qubic CLI or deployment SDK\r\n   */\r\n  static async deployContract(\r\n    _brandAddress: string,\r\n    _oracleAddress: string\r\n  ): Promise<ContractDeployResult> {\r\n    console.log('[Qubic Service] Deploying contract...');\r\n    \r\n    // Simulate deployment delay\r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n    // In production, this would:\r\n    // 1. Compile contract (if not pre-compiled)\r\n    // 2. Create IPO transaction\r\n    // 3. Broadcast to Qubic network\r\n    // 4. Wait for confirmation\r\n\r\n    const result: ContractDeployResult = {\r\n      contractId: CONFIG.CONTRACT_ID || `CONTRACT_${Date.now()}`,\r\n      txHash: this.generateMockTxHash(),\r\n      deployTick: Math.floor(Date.now() / 1000),\r\n      success: true\r\n    };\r\n\r\n    console.log('[Qubic Service] Contract deployed:', result.contractId);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Deposit funds into escrow contract\r\n   * In production: Build and sign transaction using Qubic SDK\r\n   */\r\n  static async depositFunds(\r\n    _contractId: string,\r\n    amount: number,\r\n    _influencerId: string,\r\n    _retentionDays: number = 7\r\n  ): Promise<TransactionResult> {\r\n    console.log('[Qubic Service] Depositing', amount, 'QUBIC to contract');\r\n    \r\n    // Simulate transaction delay\r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n\r\n    // Calculate platform fee\r\n    const fee = Math.round(amount * (CONFIG.PLATFORM_FEE_PERCENT / 100));\r\n    const netAmount = amount - fee;\r\n\r\n    // In production, this would:\r\n    // 1. Build transaction with depositFunds procedure\r\n    // 2. Sign with user's private key\r\n    // 3. Broadcast to Qubic RPC\r\n    // 4. Wait for confirmation\r\n\r\n    const result: TransactionResult = {\r\n      success: true,\r\n      txHash: this.generateMockTxHash(),\r\n      amount: netAmount,\r\n      fee: fee,\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    console.log('[Qubic Service] Deposit successful:', result.txHash);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Release payment to influencer\r\n   * In production: Call releasePayment() procedure on contract\r\n   */\r\n  static async releasePayment(_contractId: string): Promise<TransactionResult> {\r\n    console.log('[Qubic Service] Releasing payment...');\r\n    \r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n    // In production, this would:\r\n    // 1. Build transaction calling releasePayment()\r\n    // 2. Contract validates: score >= 95, retention period met\r\n    // 3. Contract transfers funds to influencer (zero fee)\r\n    // 4. Emit payment event\r\n\r\n    const result: TransactionResult = {\r\n      success: true,\r\n      txHash: this.generateMockTxHash(),\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    console.log('[Qubic Service] Payment released:', result.txHash);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Refund funds to brand\r\n   * In production: Call refundFunds() procedure on contract\r\n   */\r\n  static async refundFunds(_contractId: string): Promise<TransactionResult> {\r\n    console.log('[Qubic Service] Processing refund...');\r\n    \r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n\r\n    // In production, this would:\r\n    // 1. Build transaction calling refundFunds()\r\n    // 2. Contract validates: score < 95 (fraud detected)\r\n    // 3. Contract transfers funds back to brand\r\n    // 4. Emit refund event\r\n\r\n    const result: TransactionResult = {\r\n      success: true,\r\n      txHash: this.generateMockTxHash(),\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    console.log('[Qubic Service] Refund processed:', result.txHash);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Query contract state\r\n   * In production: Use Qubic RPC to query contract state\r\n   */\r\n  static async getContractState(_contractId: string): Promise<any> {\r\n    try {\r\n      // In production, query actual contract state from RPC\r\n      // const response = await fetch(`${CONFIG.QUBIC_RPC}/contract/${_contractId}/state`);\r\n      // return await response.json();\r\n\r\n      return {\r\n        isActive: true,\r\n        escrowBalance: 0,\r\n        verificationScore: 0,\r\n        isVerified: false,\r\n        isPaid: false,\r\n        isRefunded: false\r\n      };\r\n    } catch (error) {\r\n      console.error('[Qubic Service] Failed to query contract state:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get wallet balance\r\n   * In production: Query from Qubic RPC\r\n   */\r\n  static async getBalance(_address: string): Promise<number> {\r\n    try {\r\n      // In production:\r\n      // const response = await fetch(`${CONFIG.QUBIC_RPC}/balance/${_address}`);\r\n      // const data = await response.json();\r\n      // return data.balance;\r\n\r\n      return Math.floor(Math.random() * 10000) + 5000;\r\n    } catch (error) {\r\n      console.error('[Qubic Service] Failed to get balance:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current network tick\r\n   * In production: Query from Qubic RPC\r\n   */\r\n  static async getCurrentTick(): Promise<number> {\r\n    try {\r\n      const response = await fetch(`${CONFIG.QUBIC_RPC}/tick`);\r\n      const data = await response.json();\r\n      return data.tick || Math.floor(Date.now() / 1000);\r\n    } catch (error) {\r\n      console.error('[Qubic Service] Failed to get current tick:', error);\r\n      return Math.floor(Date.now() / 1000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wait for transaction confirmation\r\n   * In production: Poll RPC for transaction status\r\n   */\r\n  static async waitForConfirmation(txHash: string, maxWaitMs: number = 30000): Promise<boolean> {\r\n    const startTime = Date.now();\r\n    \r\n    while (Date.now() - startTime < maxWaitMs) {\r\n      // In production: Query transaction status\r\n      // const status = await this.getTransactionStatus(txHash);\r\n      // if (status === 'confirmed') return true;\r\n      // if (status === 'failed') return false;\r\n      \r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n      \r\n      // Mock: Always confirm after 4 seconds\r\n      if (Date.now() - startTime >= 4000) {\r\n        console.log('[Qubic Service] Transaction confirmed:', txHash);\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    console.warn('[Qubic Service] Transaction confirmation timeout');\r\n    return false;\r\n  }\r\n\r\n  // ============================================================================\r\n  // HELPER METHODS (Mock implementations for demo)\r\n  // ============================================================================\r\n\r\n  private static generateMockAddress(): string {\r\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    let address = 'QUBIC';\r\n    for (let i = 0; i < 56; i++) {\r\n      address += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    return address;\r\n  }\r\n\r\n  private static generateMockPublicKey(): string {\r\n    return 'PK_' + Math.random().toString(36).substring(2, 15).toUpperCase();\r\n  }\r\n\r\n  private static generateMockTxHash(): string {\r\n    return '0x' + Array.from({ length: 64 }, () => \r\n      Math.floor(Math.random() * 16).toString(16)\r\n    ).join('');\r\n  }\r\n\r\n  /**\r\n   * Estimate transaction fee (Always 0 on Qubic)\r\n   */\r\n  static estimateFee(): number {\r\n    return 0; // Qubic has zero transaction fees\r\n  }\r\n\r\n  /**\r\n   * Get network info\r\n   */\r\n  static getNetworkInfo(): { name: string; chainId: number; rpc: string } {\r\n    return {\r\n      name: CONFIG.NETWORK_ID === 1 ? 'Qubic Testnet' : 'Qubic Mainnet',\r\n      chainId: CONFIG.NETWORK_ID,\r\n      rpc: CONFIG.QUBIC_RPC\r\n    };\r\n  }\r\n}\r\n\r\nexport default QubicService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}