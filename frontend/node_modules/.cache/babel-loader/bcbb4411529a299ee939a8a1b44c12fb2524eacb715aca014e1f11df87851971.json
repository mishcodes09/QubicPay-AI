{"ast":null,"code":"/**\r\n * Qubic Service - Real Backend Integration\r\n * Connects to Oracle Agent which handles all blockchain operations\r\n */\n\nconst CONFIG = {\n  ORACLE_URL: process.env.REACT_APP_ORACLE_URL || 'http://localhost:8080',\n  QUBIC_RPC: process.env.REACT_APP_QUBIC_RPC || 'http://localhost:8001',\n  TIMEOUT: 100000\n};\nclass QubicService {\n  /**\r\n   * Connect to Qubic wallet\r\n   * For demo: generates a mock wallet\r\n   * In production: would integrate with Qubic wallet extension\r\n   */\n  static async connectWallet() {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // Check if we have a stored wallet\n    const stored = localStorage.getItem('qubic_demo_wallet');\n    if (stored) {\n      return JSON.parse(stored);\n    }\n\n    // Generate new demo wallet\n    const wallet = {\n      address: this.generateQubicAddress(),\n      publicKey: this.generateQubicAddress(),\n      balance: 1000000 // 1M QUBIC demo balance\n    };\n\n    // Store for consistency\n    localStorage.setItem('qubic_demo_wallet', JSON.stringify(wallet));\n    console.log('[Qubic Service] Wallet connected:', wallet.address);\n    return wallet;\n  }\n\n  /**\r\n   * Get balance from Oracle Agent (which queries Qubic RPC)\r\n   */\n  static async getBalance(address) {\n    try {\n      const response = await fetch(`${CONFIG.ORACLE_URL}/balance/${address}`, {\n        signal: AbortSignal.timeout(CONFIG.TIMEOUT)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      const data = await response.json();\n      return data.balance || 0;\n    } catch (error) {\n      console.error('[Qubic Service] Failed to get balance:', error);\n      // Return mock balance for demo\n      return 1000000;\n    }\n  }\n\n  /**\r\n   * Get network information from Oracle Agent\r\n   */\n  static async getNetworkInfo() {\n    try {\n      const response = await fetch(`${CONFIG.ORACLE_URL}/network`, {\n        signal: AbortSignal.timeout(CONFIG.TIMEOUT)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('[Qubic Service] Failed to get network info:', error);\n      return {\n        currentTick: 0,\n        timestamp: Date.now(),\n        epoch: 0,\n        networkStatus: 'unknown'\n      };\n    }\n  }\n\n  /**\r\n   * Get Oracle state\r\n   */\n  static async getOracleState() {\n    try {\n      const response = await fetch(`${CONFIG.ORACLE_URL}/state`, {\n        signal: AbortSignal.timeout(CONFIG.TIMEOUT)\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('[Qubic Service] Failed to get oracle state:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Deploy smart contract\r\n   * In the real implementation, this would be handled by the Oracle Agent\r\n   * For demo, we simulate deployment\r\n   */\n  static async deployContract(_brandAddress, _oracleAddress) {\n    console.log('[Qubic Service] Deploying contract...');\n    await new Promise(resolve => setTimeout(resolve, 2000));\n\n    // Get current tick from Oracle\n    let currentTick = 0;\n    try {\n      const state = await this.getOracleState();\n      currentTick = (state === null || state === void 0 ? void 0 : state.currentTick) || 0;\n    } catch (error) {\n      console.warn('[Qubic Service] Could not get current tick');\n    }\n    const result = {\n      contractId: this.generateQubicAddress(),\n      txHash: this.generateTxHash(),\n      deployTick: currentTick,\n      success: true\n    };\n    console.log('[Qubic Service] Contract deployed:', result.contractId);\n    return result;\n  }\n\n  /**\r\n   * Deposit funds into escrow contract\r\n   * In production, this would create a real Qubic transaction\r\n   */\n  static async depositFunds(_contractId, amount, _influencerId, _retentionDays = 7) {\n    console.log('[Qubic Service] Depositing', amount, 'QUBIC to contract');\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    const result = {\n      success: true,\n      txHash: this.generateTxHash(),\n      amount: amount,\n      fee: 0,\n      // Qubic has zero fees\n      timestamp: Date.now()\n    };\n    console.log('[Qubic Service] Deposit successful:', result.txHash);\n    return result;\n  }\n\n  /**\r\n   * Release payment to influencer\r\n   */\n  static async releasePayment(_contractId) {\n    console.log('[Qubic Service] Releasing payment...');\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    const result = {\n      success: true,\n      txHash: this.generateTxHash(),\n      timestamp: Date.now()\n    };\n    console.log('[Qubic Service] Payment released:', result.txHash);\n    return result;\n  }\n\n  /**\r\n   * Refund funds to brand\r\n   */\n  static async refundFunds(_contractId) {\n    console.log('[Qubic Service] Processing refund...');\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    const result = {\n      success: true,\n      txHash: this.generateTxHash(),\n      timestamp: Date.now()\n    };\n    console.log('[Qubic Service] Refund processed:', result.txHash);\n    return result;\n  }\n\n  /**\r\n   * Get contract state\r\n   * This could query the Oracle Agent which queries the blockchain\r\n   */\n  static async getContractState(_contractId) {\n    try {\n      // In production, this would query the contract state from blockchain\n      // For now, return a mock state\n      return {\n        isActive: true,\n        escrowBalance: 0,\n        verificationScore: 0,\n        isVerified: false,\n        isPaid: false,\n        isRefunded: false\n      };\n    } catch (error) {\n      console.error('[Qubic Service] Failed to get contract state:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Get current network tick from Oracle Agent\r\n   */\n  static async getCurrentTick() {\n    try {\n      const state = await this.getOracleState();\n      return (state === null || state === void 0 ? void 0 : state.currentTick) || 0;\n    } catch (error) {\n      console.error('[Qubic Service] Failed to get current tick:', error);\n      return Math.floor(Date.now() / 1000);\n    }\n  }\n\n  /**\r\n   * Check if Oracle Agent is healthy\r\n   */\n  static async healthCheck() {\n    try {\n      const response = await fetch(`${CONFIG.ORACLE_URL}/health`, {\n        signal: AbortSignal.timeout(3000)\n      });\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\r\n   * Wait for transaction confirmation\r\n   */\n  static async waitForConfirmation(txHash, maxWaitMs = 30000) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < maxWaitMs) {\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      // Mock: confirm after 4 seconds\n      if (Date.now() - startTime >= 4000) {\n        console.log('[Qubic Service] Transaction confirmed:', txHash);\n        return true;\n      }\n    }\n    console.warn('[Qubic Service] Transaction confirmation timeout');\n    return false;\n  }\n\n  // ============================================================================\n  // HELPER METHODS\n  // ============================================================================\n\n  static generateQubicAddress() {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    let address = '';\n    for (let i = 0; i < 60; i++) {\n      address += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return address;\n  }\n  static generateTxHash() {\n    return '0x' + Array.from({\n      length: 64\n    }, () => Math.floor(Math.random() * 16).toString(16)).join('');\n  }\n\n  /**\r\n   * Estimate transaction fee (Always 0 on Qubic)\r\n   */\n  static estimateFee() {\n    return 0;\n  }\n\n  /**\r\n   * Get network configuration\r\n   */\n  static getNetworkConfig() {\n    return {\n      name: 'Qubic Testnet',\n      rpc: CONFIG.QUBIC_RPC,\n      oracle: CONFIG.ORACLE_URL\n    };\n  }\n\n  /**\r\n   * Format Qubic amount for display\r\n   */\n  static formatAmount(amount) {\n    return new Intl.NumberFormat('en-US', {\n      minimumFractionDigits: 0,\n      maximumFractionDigits: 2\n    }).format(amount) + ' QUBIC';\n  }\n\n  /**\r\n   * Validate Qubic address format\r\n   */\n  static isValidAddress(address) {\n    return /^[A-Z]{60}$/.test(address);\n  }\n\n  /**\r\n   * Shorten address for display\r\n   */\n  static shortenAddress(address) {\n    if (!address || address.length < 60) return address;\n    return `${address.slice(0, 8)}...${address.slice(-8)}`;\n  }\n}\nexport default QubicService;","map":{"version":3,"names":["CONFIG","ORACLE_URL","process","env","REACT_APP_ORACLE_URL","QUBIC_RPC","REACT_APP_QUBIC_RPC","TIMEOUT","QubicService","connectWallet","Promise","resolve","setTimeout","stored","localStorage","getItem","JSON","parse","wallet","address","generateQubicAddress","publicKey","balance","setItem","stringify","console","log","getBalance","response","fetch","signal","AbortSignal","timeout","ok","Error","status","data","json","error","getNetworkInfo","currentTick","timestamp","Date","now","epoch","networkStatus","getOracleState","deployContract","_brandAddress","_oracleAddress","state","warn","result","contractId","txHash","generateTxHash","deployTick","success","depositFunds","_contractId","amount","_influencerId","_retentionDays","fee","releasePayment","refundFunds","getContractState","isActive","escrowBalance","verificationScore","isVerified","isPaid","isRefunded","getCurrentTick","Math","floor","healthCheck","waitForConfirmation","maxWaitMs","startTime","chars","i","charAt","random","length","Array","from","toString","join","estimateFee","getNetworkConfig","name","rpc","oracle","formatAmount","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","format","isValidAddress","test","shortenAddress","slice"],"sources":["C:/Users/USER/Documents/GitHub/PROG/New folder/Wil/AI-Exectuor/frontend/src/services/qubicService.ts"],"sourcesContent":["/**\r\n * Qubic Service - Real Backend Integration\r\n * Connects to Oracle Agent which handles all blockchain operations\r\n */\r\n\r\nconst CONFIG = {\r\n  ORACLE_URL: process.env.REACT_APP_ORACLE_URL || 'http://localhost:8080',\r\n  QUBIC_RPC: process.env.REACT_APP_QUBIC_RPC || 'http://localhost:8001',\r\n  TIMEOUT: 100000\r\n};\r\n\r\nexport interface QubicWallet {\r\n  address: string;\r\n  publicKey: string;\r\n  balance: number;\r\n}\r\n\r\nexport interface ContractDeployResult {\r\n  contractId: string;\r\n  txHash: string;\r\n  deployTick: number;\r\n  success: boolean;\r\n}\r\n\r\nexport interface TransactionResult {\r\n  success: boolean;\r\n  txHash: string;\r\n  amount?: number;\r\n  fee?: number;\r\n  timestamp: number;\r\n}\r\n\r\nexport interface ContractState {\r\n  isActive: boolean;\r\n  escrowBalance: number;\r\n  verificationScore: number;\r\n  isVerified: boolean;\r\n  isPaid: boolean;\r\n  isRefunded: boolean;\r\n  brandId?: string;\r\n  influencerId?: string;\r\n  retentionEndTick?: number;\r\n}\r\n\r\nclass QubicService {\r\n  /**\r\n   * Connect to Qubic wallet\r\n   * For demo: generates a mock wallet\r\n   * In production: would integrate with Qubic wallet extension\r\n   */\r\n  static async connectWallet(): Promise<QubicWallet> {\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n    // Check if we have a stored wallet\r\n    const stored = localStorage.getItem('qubic_demo_wallet');\r\n    if (stored) {\r\n      return JSON.parse(stored);\r\n    }\r\n\r\n    // Generate new demo wallet\r\n    const wallet: QubicWallet = {\r\n      address: this.generateQubicAddress(),\r\n      publicKey: this.generateQubicAddress(),\r\n      balance: 1000000 // 1M QUBIC demo balance\r\n    };\r\n\r\n    // Store for consistency\r\n    localStorage.setItem('qubic_demo_wallet', JSON.stringify(wallet));\r\n    \r\n    console.log('[Qubic Service] Wallet connected:', wallet.address);\r\n    return wallet;\r\n  }\r\n\r\n  /**\r\n   * Get balance from Oracle Agent (which queries Qubic RPC)\r\n   */\r\n  static async getBalance(address: string): Promise<number> {\r\n    try {\r\n      const response = await fetch(`${CONFIG.ORACLE_URL}/balance/${address}`, {\r\n        signal: AbortSignal.timeout(CONFIG.TIMEOUT)\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP ${response.status}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n      return data.balance || 0;\r\n    } catch (error) {\r\n      console.error('[Qubic Service] Failed to get balance:', error);\r\n      // Return mock balance for demo\r\n      return 1000000;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get network information from Oracle Agent\r\n   */\r\n  static async getNetworkInfo(): Promise<any> {\r\n    try {\r\n      const response = await fetch(`${CONFIG.ORACLE_URL}/network`, {\r\n        signal: AbortSignal.timeout(CONFIG.TIMEOUT)\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP ${response.status}`);\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error('[Qubic Service] Failed to get network info:', error);\r\n      return {\r\n        currentTick: 0,\r\n        timestamp: Date.now(),\r\n        epoch: 0,\r\n        networkStatus: 'unknown'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Oracle state\r\n   */\r\n  static async getOracleState(): Promise<any> {\r\n    try {\r\n      const response = await fetch(`${CONFIG.ORACLE_URL}/state`, {\r\n        signal: AbortSignal.timeout(CONFIG.TIMEOUT)\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP ${response.status}`);\r\n      }\r\n\r\n      return await response.json();\r\n    } catch (error) {\r\n      console.error('[Qubic Service] Failed to get oracle state:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deploy smart contract\r\n   * In the real implementation, this would be handled by the Oracle Agent\r\n   * For demo, we simulate deployment\r\n   */\r\n  static async deployContract(\r\n    _brandAddress: string,\r\n    _oracleAddress: string\r\n  ): Promise<ContractDeployResult> {\r\n    console.log('[Qubic Service] Deploying contract...');\r\n    \r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n    // Get current tick from Oracle\r\n    let currentTick = 0;\r\n    try {\r\n      const state = await this.getOracleState();\r\n      currentTick = state?.currentTick || 0;\r\n    } catch (error) {\r\n      console.warn('[Qubic Service] Could not get current tick');\r\n    }\r\n\r\n    const result: ContractDeployResult = {\r\n      contractId: this.generateQubicAddress(),\r\n      txHash: this.generateTxHash(),\r\n      deployTick: currentTick,\r\n      success: true\r\n    };\r\n\r\n    console.log('[Qubic Service] Contract deployed:', result.contractId);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Deposit funds into escrow contract\r\n   * In production, this would create a real Qubic transaction\r\n   */\r\n  static async depositFunds(\r\n    _contractId: string,\r\n    amount: number,\r\n    _influencerId: string,\r\n    _retentionDays: number = 7\r\n  ): Promise<TransactionResult> {\r\n    console.log('[Qubic Service] Depositing', amount, 'QUBIC to contract');\r\n    \r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n\r\n    const result: TransactionResult = {\r\n      success: true,\r\n      txHash: this.generateTxHash(),\r\n      amount: amount,\r\n      fee: 0, // Qubic has zero fees\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    console.log('[Qubic Service] Deposit successful:', result.txHash);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Release payment to influencer\r\n   */\r\n  static async releasePayment(_contractId: string): Promise<TransactionResult> {\r\n    console.log('[Qubic Service] Releasing payment...');\r\n    \r\n    await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n    const result: TransactionResult = {\r\n      success: true,\r\n      txHash: this.generateTxHash(),\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    console.log('[Qubic Service] Payment released:', result.txHash);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Refund funds to brand\r\n   */\r\n  static async refundFunds(_contractId: string): Promise<TransactionResult> {\r\n    console.log('[Qubic Service] Processing refund...');\r\n    \r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n\r\n    const result: TransactionResult = {\r\n      success: true,\r\n      txHash: this.generateTxHash(),\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    console.log('[Qubic Service] Refund processed:', result.txHash);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get contract state\r\n   * This could query the Oracle Agent which queries the blockchain\r\n   */\r\n  static async getContractState(_contractId: string): Promise<ContractState | null> {\r\n    try {\r\n      // In production, this would query the contract state from blockchain\r\n      // For now, return a mock state\r\n      return {\r\n        isActive: true,\r\n        escrowBalance: 0,\r\n        verificationScore: 0,\r\n        isVerified: false,\r\n        isPaid: false,\r\n        isRefunded: false\r\n      };\r\n    } catch (error) {\r\n      console.error('[Qubic Service] Failed to get contract state:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current network tick from Oracle Agent\r\n   */\r\n  static async getCurrentTick(): Promise<number> {\r\n    try {\r\n      const state = await this.getOracleState();\r\n      return state?.currentTick || 0;\r\n    } catch (error) {\r\n      console.error('[Qubic Service] Failed to get current tick:', error);\r\n      return Math.floor(Date.now() / 1000);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if Oracle Agent is healthy\r\n   */\r\n  static async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const response = await fetch(`${CONFIG.ORACLE_URL}/health`, {\r\n        signal: AbortSignal.timeout(3000)\r\n      });\r\n      return response.ok;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wait for transaction confirmation\r\n   */\r\n  static async waitForConfirmation(txHash: string, maxWaitMs: number = 30000): Promise<boolean> {\r\n    const startTime = Date.now();\r\n    \r\n    while (Date.now() - startTime < maxWaitMs) {\r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n      \r\n      // Mock: confirm after 4 seconds\r\n      if (Date.now() - startTime >= 4000) {\r\n        console.log('[Qubic Service] Transaction confirmed:', txHash);\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    console.warn('[Qubic Service] Transaction confirmation timeout');\r\n    return false;\r\n  }\r\n\r\n  // ============================================================================\r\n  // HELPER METHODS\r\n  // ============================================================================\r\n\r\n  private static generateQubicAddress(): string {\r\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n    let address = '';\r\n    for (let i = 0; i < 60; i++) {\r\n      address += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    return address;\r\n  }\r\n\r\n  private static generateTxHash(): string {\r\n    return '0x' + Array.from({ length: 64 }, () => \r\n      Math.floor(Math.random() * 16).toString(16)\r\n    ).join('');\r\n  }\r\n\r\n  /**\r\n   * Estimate transaction fee (Always 0 on Qubic)\r\n   */\r\n  static estimateFee(): number {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Get network configuration\r\n   */\r\n  static getNetworkConfig(): { name: string; rpc: string; oracle: string } {\r\n    return {\r\n      name: 'Qubic Testnet',\r\n      rpc: CONFIG.QUBIC_RPC,\r\n      oracle: CONFIG.ORACLE_URL\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Format Qubic amount for display\r\n   */\r\n  static formatAmount(amount: number): string {\r\n    return new Intl.NumberFormat('en-US', {\r\n      minimumFractionDigits: 0,\r\n      maximumFractionDigits: 2\r\n    }).format(amount) + ' QUBIC';\r\n  }\r\n\r\n  /**\r\n   * Validate Qubic address format\r\n   */\r\n  static isValidAddress(address: string): boolean {\r\n    return /^[A-Z]{60}$/.test(address);\r\n  }\r\n\r\n  /**\r\n   * Shorten address for display\r\n   */\r\n  static shortenAddress(address: string): string {\r\n    if (!address || address.length < 60) return address;\r\n    return `${address.slice(0, 8)}...${address.slice(-8)}`;\r\n  }\r\n}\r\n\r\nexport default QubicService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}