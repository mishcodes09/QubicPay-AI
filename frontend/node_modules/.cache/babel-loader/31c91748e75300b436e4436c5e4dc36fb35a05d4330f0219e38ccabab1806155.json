{"ast":null,"code":"var _s = $RefreshSig$();\n/**\r\n * useContractState Hook\r\n * Manages smart contract state and polling\r\n */\nimport { useState, useEffect, useCallback } from 'react';\nimport QubicService from '../services/qubicService';\nexport const useContractState = (contractId, pollingInterval = 5000) => {\n  _s();\n  const [contractState, setContractState] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const fetchContractState = useCallback(async () => {\n    if (!contractId) {\n      setContractState(null);\n      return;\n    }\n    setIsLoading(true);\n    setError(null);\n    try {\n      const state = await QubicService.getContractState(contractId);\n      setContractState(state);\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch contract state';\n      setError(errorMessage);\n      console.error('Contract state fetch error:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [contractId]);\n\n  // Initial fetch\n  useEffect(() => {\n    fetchContractState();\n  }, [fetchContractState]);\n\n  // Polling\n  useEffect(() => {\n    if (!contractId || pollingInterval <= 0) return;\n    const interval = setInterval(() => {\n      fetchContractState();\n    }, pollingInterval);\n    return () => clearInterval(interval);\n  }, [contractId, pollingInterval, fetchContractState]);\n  return {\n    contractState,\n    isLoading,\n    error,\n    refetch: fetchContractState\n  };\n};\n_s(useContractState, \"5aYqThXaBtrBF2kYFy2Zs1XwWFg=\");","map":{"version":3,"names":["useState","useEffect","useCallback","QubicService","useContractState","contractId","pollingInterval","_s","contractState","setContractState","isLoading","setIsLoading","error","setError","fetchContractState","state","getContractState","err","errorMessage","Error","message","console","interval","setInterval","clearInterval","refetch"],"sources":["C:/Users/USER/Documents/GitHub/PROG/New folder/Wil/AI-Exectuor/frontend/src/hooks/useContractState.ts"],"sourcesContent":["/**\r\n * useContractState Hook\r\n * Manages smart contract state and polling\r\n */\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport QubicService from '../services/qubicService';\r\n\r\ninterface ContractState {\r\n  isActive: boolean;\r\n  escrowBalance: number;\r\n  verificationScore: number;\r\n  isVerified: boolean;\r\n  isPaid: boolean;\r\n  isRefunded: boolean;\r\n  brandId?: string;\r\n  influencerId?: string;\r\n  retentionEndTick?: number;\r\n}\r\n\r\ninterface UseContractStateReturn {\r\n  contractState: ContractState | null;\r\n  isLoading: boolean;\r\n  error: string | null;\r\n  refetch: () => Promise<void>;\r\n}\r\n\r\nexport const useContractState = (contractId: string | null, pollingInterval: number = 5000): UseContractStateReturn => {\r\n  const [contractState, setContractState] = useState<ContractState | null>(null);\r\n  const [isLoading, setIsLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  const fetchContractState = useCallback(async () => {\r\n    if (!contractId) {\r\n      setContractState(null);\r\n      return;\r\n    }\r\n\r\n    setIsLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      const state = await QubicService.getContractState(contractId);\r\n      setContractState(state);\r\n    } catch (err) {\r\n      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch contract state';\r\n      setError(errorMessage);\r\n      console.error('Contract state fetch error:', err);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [contractId]);\r\n\r\n  // Initial fetch\r\n  useEffect(() => {\r\n    fetchContractState();\r\n  }, [fetchContractState]);\r\n\r\n  // Polling\r\n  useEffect(() => {\r\n    if (!contractId || pollingInterval <= 0) return;\r\n\r\n    const interval = setInterval(() => {\r\n      fetchContractState();\r\n    }, pollingInterval);\r\n\r\n    return () => clearInterval(interval);\r\n  }, [contractId, pollingInterval, fetchContractState]);\r\n\r\n  return {\r\n    contractState,\r\n    isLoading,\r\n    error,\r\n    refetch: fetchContractState\r\n  };\r\n};"],"mappings":";AAAA;AACA;AACA;AACA;AACA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AACxD,OAAOC,YAAY,MAAM,0BAA0B;AAqBnD,OAAO,MAAMC,gBAAgB,GAAGA,CAACC,UAAyB,EAAEC,eAAuB,GAAG,IAAI,KAA6B;EAAAC,EAAA;EACrH,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGT,QAAQ,CAAuB,IAAI,CAAC;EAC9E,MAAM,CAACU,SAAS,EAAEC,YAAY,CAAC,GAAGX,QAAQ,CAAU,KAAK,CAAC;EAC1D,MAAM,CAACY,KAAK,EAAEC,QAAQ,CAAC,GAAGb,QAAQ,CAAgB,IAAI,CAAC;EAEvD,MAAMc,kBAAkB,GAAGZ,WAAW,CAAC,YAAY;IACjD,IAAI,CAACG,UAAU,EAAE;MACfI,gBAAgB,CAAC,IAAI,CAAC;MACtB;IACF;IAEAE,YAAY,CAAC,IAAI,CAAC;IAClBE,QAAQ,CAAC,IAAI,CAAC;IAEd,IAAI;MACF,MAAME,KAAK,GAAG,MAAMZ,YAAY,CAACa,gBAAgB,CAACX,UAAU,CAAC;MAC7DI,gBAAgB,CAACM,KAAK,CAAC;IACzB,CAAC,CAAC,OAAOE,GAAG,EAAE;MACZ,MAAMC,YAAY,GAAGD,GAAG,YAAYE,KAAK,GAAGF,GAAG,CAACG,OAAO,GAAG,gCAAgC;MAC1FP,QAAQ,CAACK,YAAY,CAAC;MACtBG,OAAO,CAACT,KAAK,CAAC,6BAA6B,EAAEK,GAAG,CAAC;IACnD,CAAC,SAAS;MACRN,YAAY,CAAC,KAAK,CAAC;IACrB;EACF,CAAC,EAAE,CAACN,UAAU,CAAC,CAAC;;EAEhB;EACAJ,SAAS,CAAC,MAAM;IACda,kBAAkB,CAAC,CAAC;EACtB,CAAC,EAAE,CAACA,kBAAkB,CAAC,CAAC;;EAExB;EACAb,SAAS,CAAC,MAAM;IACd,IAAI,CAACI,UAAU,IAAIC,eAAe,IAAI,CAAC,EAAE;IAEzC,MAAMgB,QAAQ,GAAGC,WAAW,CAAC,MAAM;MACjCT,kBAAkB,CAAC,CAAC;IACtB,CAAC,EAAER,eAAe,CAAC;IAEnB,OAAO,MAAMkB,aAAa,CAACF,QAAQ,CAAC;EACtC,CAAC,EAAE,CAACjB,UAAU,EAAEC,eAAe,EAAEQ,kBAAkB,CAAC,CAAC;EAErD,OAAO;IACLN,aAAa;IACbE,SAAS;IACTE,KAAK;IACLa,OAAO,EAAEX;EACX,CAAC;AACH,CAAC;AAACP,EAAA,CAhDWH,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}